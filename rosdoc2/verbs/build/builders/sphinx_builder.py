# Copyright 2020 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import json
import logging
import os
import pkg_resources
import setuptools
import shutil
import subprocess
import sys

from jinja2 import Template
from ..builder import Builder
from ..collect_inventory_files import collect_inventory_files
from ..create_format_map_from_package import create_format_map_from_package

logger = logging.getLogger('rosdoc2')

def generate_template_variables(
      intersphinx_mapping_extensions,
      breathe_projects,
      build_context,
      user_sourcedir,
      package_src_directory
    ):
    """Generate the variables used by templates for conf.py and index.rst"""

    package = build_context.package
    template_variables = create_format_map_from_package(package)
    root_title = f'Welcome to the documentation for {package.name}'

    # standard urls in a package definition
    url_repository = ''
    url_website = ''
    url_bugtracker = ''
    for url in package.urls:
        if url.type == 'repository':
            url_repository = f'* `Repository <{url.url}>`_'
        if url.type == 'website':
            url_website = f'* `Website <{url.url}>`_'
        if url.type == 'bugtracker':
            url_bugtracker = f'* `Bugtracker <{url.url}>`_'

    template_variables.update({
        'always_run_doxygen': build_context.always_run_doxygen,
        'breathe_projects': ',\n'.join(breathe_projects) + '\n    ',
        'build_type': build_context.build_type,
        'exec_depends': [exec_depend.name for exec_depend in package.exec_depends],
        'intersphinx_mapping_extensions': ',\n        '.join(intersphinx_mapping_extensions),
        'package': package,
        'package_authors': ', '.join(set(
            [a.name for a in package.authors] + [m.name for m in package.maintainers]
        )),
        'package_licenses': ', '.join(package.licenses),
        'package_src_directory': package_src_directory,
        'package_toc_entry': generate_package_toc_entry(build_context=build_context),
        'package_underline': '=' * len(package.name),
        'package_version_short': '.'.join(package.version.split('.')[0:2]),
        'root_title': root_title,
        'root_title_underline': '=' * len(root_title),
        'url_bugtracker': url_bugtracker,
        'url_repository': url_repository,
        'url_website': url_website,
        'user_sourcedir': os.path.abspath(user_sourcedir),
    })
    return template_variables

def generate_package_toc_entry(*, build_context) -> str:
    build_type = build_context.build_type
    always_run_doxygen = build_context.always_run_doxygen
    always_run_sphinx_apidoc = build_context.always_run_sphinx_apidoc
    # The TOC entries have to be indented by three (or any N) spaces
    # inside the string to fall under the `:toctree:` directive
    toc_entry_py = f"""
   {build_context.package.name} Python API <generated/python/modules>"""
    toc_entry_cpp = """
   api/library_root
   Full C/C++ API <generated/unabridged_api>
   File structure <generated/unabridged_orphan>"""
    toc_entry = ''

    if build_type == 'ament_python' or always_run_sphinx_apidoc:
        toc_entry += toc_entry_py
    if build_type in ['ament_cmake', 'cmake'] or always_run_doxygen:
        toc_entry += toc_entry_cpp

    return toc_entry

rosdoc2_wrapping_conf_py_preamble = """\
## Generated by rosdoc2.verbs.build.builders.SphinxBuilder.
## This conf.py imports the variables from the user defined (or default if none
## was provided) conf.py, extends the settings to support Breathe and Exhale and
## to set up intersphinx mappings correctly, among other things.

import os
import sys

## Set values for variables obtained by running conf.py.
"""

rosdoc2_wrapping_conf_py_template = """
## Based on the rosdoc2 settings, do various things to the settings before
## letting Sphinx continue.

def ensure_global(name, default):
    if name not in globals():
        globals()[name] = default

ensure_global('rosdoc2_settings', {{}})
ensure_global('extensions', [])

if rosdoc2_settings.get('enable_autodoc', True):
    print('[rosdoc2] enabling autodoc', file=sys.stderr)
    extensions.append('sphinx.ext.autodoc')
    # Provide all runtime dependencies to be mocked up
    # Note: `autodoc` only mocks up those modules that it actually cannot locate in PATH
    autodoc_mock_imports = {exec_depends}
    # Add the package directory to PATH, so that `sphinx-autodoc` can import it
    sys.path.insert(0, os.path.dirname('{package_src_directory}'))

if rosdoc2_settings.get('enable_intersphinx', True):
    print('[rosdoc2] enabling intersphinx', file=sys.stderr)
    extensions.append('sphinx.ext.intersphinx')

build_type = '{build_type}'
always_run_doxygen = {always_run_doxygen}
# By default, the `exhale`/`breathe` extensions should be added if `doxygen` was invoked
is_doxygen_invoked = build_type in ('ament_cmake', 'cmake') or always_run_doxygen

if rosdoc2_settings.get('enable_breathe', is_doxygen_invoked):
    # Configure Breathe.
    # Breathe ingests the XML output from Doxygen and makes it accessible from Sphinx.
    print('[rosdoc2] enabling breathe', file=sys.stderr)
    # First check that doxygen would have been run
    if not is_doxygen_invoked:
        raise RuntimeError(
            "Cannot enable the 'breathe' extension if 'doxygen' is not invoked."
            "Please enable 'always_run_doxygen' if the package is not an"
            "'ament_cmake' or 'cmake' package.")
    ensure_global('breathe_projects', {{}})
    breathe_projects.update({{{breathe_projects}}})
    if breathe_projects:
        # Enable Breathe and arbitrarily select the first project.
        extensions.append('breathe')
        breathe_default_project = next(iter(breathe_projects.keys()))

if rosdoc2_settings.get('enable_exhale', is_doxygen_invoked):
    # Configure Exhale.
    # Exhale uses the output of Doxygen and Breathe to create easier to browse pages
    # for classes and functions documented with Doxygen.
    # This is similar to the class hierarchies and namespace listing provided by
    # Doxygen out of the box.
    print('[rosdoc2] enabling exhale', file=sys.stderr)
    # First check that doxygen would have been run
    if not is_doxygen_invoked:
        raise RuntimeError(
            "Cannot enable the 'breathe' extension if 'doxygen' is not invoked."
            "Please enable 'always_run_doxygen' if the package is not an"
            "'ament_cmake' or 'cmake' package.")
    extensions.append('exhale')
    ensure_global('exhale_args', {{}})

    default_exhale_specs_mapping = {{
        'page': [':content-only:'],
        **dict.fromkeys(
            ['class', 'struct'],
            [':members:', ':protected-members:', ':undoc-members:']),
    }}

    exhale_specs_mapping = rosdoc2_settings.get(
        'exhale_specs_mapping', default_exhale_specs_mapping)

    from exhale import utils
    exhale_args.update({{
        # These arguments are required.
        "containmentFolder": "{user_sourcedir}/generated",
        "rootFileName": "index.rst",
        "rootFileTitle": "{package_name} C/C++ API",
        "doxygenStripFromPath": "..",
        # Suggested optional arguments.
        "createTreeView": True,
        "fullToctreeMaxDepth": 1,
        "unabridgedOrphanKinds": [],
        "fullApiSubSectionTitle": "Reference",
        # TIP: if using the sphinx-bootstrap-theme, you need
        # "treeViewIsBootstrap": True,
        "exhaleExecutesDoxygen": False,
        # Maps markdown files to the "md" lexer, and not the "markdown" lexer
        # Pygments registers "md" as a valid markdown lexer, and not "markdown"
        "lexerMapping": {{r".*\.(md|markdown)$": "md",}},
        "customSpecificationsMapping": utils.makeCustomSpecificationsMapping(
            lambda kind: exhale_specs_mapping.get(kind, [])),
    }})

if rosdoc2_settings.get('override_theme', True):
    extensions.append('sphinx_rtd_theme')
    html_theme = 'sphinx_rtd_theme'
    print(f"[rosdoc2] overriding theme to be '{{html_theme}}'", file=sys.stderr)

if rosdoc2_settings.get('automatically_extend_intersphinx_mapping', True):
    print(f"[rosdoc2] extending intersphinx mapping", file=sys.stderr)
    if 'sphinx.ext.intersphinx' not in extensions:
        raise RuntimeError(
            "Cannot extend intersphinx mapping if 'sphinx.ext.intersphinx' "
            "has not been added to the extensions")
    ensure_global('intersphinx_mapping', {{
        {intersphinx_mapping_extensions}
    }})

if rosdoc2_settings.get('support_markdown', True):
    print(f"[rosdoc2] adding markdown parser", file=sys.stderr)
    # The `myst_parser` is used specifically if there are markdown files
    # in the sphinx project
    extensions.append('myst_parser')

# Provide tags to conditionally include documentation
if '{url_repository}':
    tags.add('url_repository')
    tags.add('url_any')
if '{url_website}':
    tags.add('url_website')
    tags.add('url_any')
if '{url_bugtracker}':
    tags.add('url_bugtracker')
    tags.add('url_any')
"""  # noqa: W605


class SphinxBuilder(Builder):
    """
    Builder for Sphinx.

    Supported keys for the builder_entry_dictionary include:

    - name (str) (required)
      - name of the documentation, used in reference to the content generated by this builder
    - builder (str) (required)
      - required for all builders, must be 'sphinx' to use this class
    - sphinx_sourcedir (str) (optional)
      - directory containing the Sphinx project, i.e. the `conf.py`, the setting
        you would pass to sphinx-build as SOURCEDIR. Defaults to `doc`.
    """

    def __init__(self, builder_name, builder_entry_dictionary, build_context):
        """Construct a new SphinxBuilder."""
        super(SphinxBuilder, self).__init__(
            builder_name,
            builder_entry_dictionary,
            build_context)

        assert self.builder_type == 'sphinx'

        self.sphinx_sourcedir = None
        self.doxygen_xml_directory = None
        configuration_file_path = build_context.configuration_file_path
        if not os.path.exists(configuration_file_path):
            # This can be the case if the default config is used from a string.
            # Use package.xml instead.
            configuration_file_path = self.build_context.package.filename
        configuration_file_dir = os.path.abspath(os.path.dirname(configuration_file_path))

        # Process keys.
        for key, value in builder_entry_dictionary.items():
            if key in ['name', 'output_dir']:
                continue
            if key == 'sphinx_sourcedir':
                sphinx_sourcedir = os.path.join(configuration_file_dir, value)
                if not os.path.isdir(sphinx_sourcedir):
                    raise RuntimeError(
                        f"Error Sphinx SOURCEDIR '{value}' does not exist relative "
                        f"to '{configuration_file_path}', or is not a directory.")
                self.sphinx_sourcedir = sphinx_sourcedir
            elif key == 'doxygen_xml_directory':
                self.doxygen_xml_directory = value
                # Must check for the existence of this later, as it may not have been made yet.
            else:
                raise RuntimeError(f"Error the Sphinx builder does not support key '{key}'")

    def build(self, *, doc_build_folder, output_staging_directory):
        """Actually do the build."""
        # Check that doxygen_xml_directory exists relative to output staging, if specified.
        should_run_doxygen = \
            self.build_context.build_type in ('ament_cmake', 'cmake') or \
            self.build_context.always_run_doxygen
        if self.doxygen_xml_directory is not None and should_run_doxygen:
            self.doxygen_xml_directory = \
                os.path.join(output_staging_directory, self.doxygen_xml_directory)
            self.doxygen_xml_directory = os.path.abspath(self.doxygen_xml_directory)
            if not os.path.isdir(self.doxygen_xml_directory):
                raise RuntimeError(
                    f"Error the 'doxygen_xml_directory' specified "
                    f"'{self.doxygen_xml_directory}' does not exist.")

        # Check if the user provided a sourcedir.
        sourcedir = self.sphinx_sourcedir
        if sourcedir is not None:
            # We do not need to check if this directory exists, as that was done in __init__.
            logger.info(
                f"Note: the user provided sourcedir for Sphinx '{sourcedir}' will be used.")
        else:
            # If the user does not supply a Sphinx sourcedir, check the standard locations.
            standard_sphinx_sourcedir = self.locate_sphinx_sourcedir_from_standard_locations()
            if standard_sphinx_sourcedir is not None:
                logger.info(
                    'Note: no sourcedir provided, but a Sphinx sourcedir located in the '
                    f"standard location '{standard_sphinx_sourcedir}' and that will be used.")
                sourcedir = standard_sphinx_sourcedir
            else:
                # If the user does not supply a Sphinx sourcedir, and there is no Sphinx project
                # in the conventional location, i.e. '<package dir>/doc', create a temporary
                # Sphinx project in the doc build directory to enable cross-references.
                logger.info(
                    'Note: no sourcedir provided by the user and no Sphinx sourcedir was found '
                    'in the standard locations, therefore using a default Sphinx configuration.')
                sourcedir = os.path.join(doc_build_folder, 'default_sphinx_project')
                self.generate_default_project_into_directory(sourcedir)

        # Collect intersphinx mapping extensions from discovered inventory files.
        inventory_files = \
            collect_inventory_files(self.build_context.tool_options.cross_reference_directory)
        base_url = self.build_context.tool_options.base_url
        intersphinx_mapping_extensions = [
            f"'{package_name}': "
            f"('{base_url}/{package_name}/{inventory_dict['location_data']['relative_root']}', "
            f"'{os.path.abspath(inventory_dict['inventory_file'])}')"
            for package_name, inventory_dict in inventory_files.items()
            # Exclude ourselves.
            if package_name != self.build_context.package.name
        ]

        package_xml_directory = os.path.dirname(self.build_context.package.filename)
        # If 'python_source' is specified, construct 'package_src_directory' from it
        if self.build_context.python_source is not None:
            package_src_directory = \
                os.path.abspath(os.path.join(
                    package_xml_directory,
                    self.build_context.python_source))
        # If not provided, try to find the package source direcotry
        else:
            package_list = setuptools.find_packages(where=package_xml_directory)
            if self.build_context.package.name in package_list:
                package_src_directory = os.path.abspath(os.path.join(
                    package_xml_directory,
                    self.build_context.package.name))
            else:
                package_src_directory = None

        breathe_projects = []
        if self.doxygen_xml_directory is not None:
            breathe_projects.append(
                f'        "{self.build_context.package.name} Doxygen Project": ' +
                f'"{self.doxygen_xml_directory}"')

        # Prepare the template variables for formatting strings.
        self.template_variables = generate_template_variables(
            intersphinx_mapping_extensions,
            breathe_projects,
            self.build_context,
            sourcedir,
            package_src_directory
        )

        # If the user or this script supplied template files, use them
        # to update the project configuration files.
        self.create_or_update_doc_config_from_templates(sourcedir)

        # Setup rosdoc2 Sphinx file which will include and extend the one in `sourcedir`.
        self.generate_wrapping_rosdoc2_sphinx_project_into_directory(
            doc_build_folder,
            sourcedir)

        # If the package has build type `ament_python`, or if the user configured
        # to run `sphinx-apidoc`, then invoke `sphinx-apidoc` before building
        if (
            self.build_context.build_type == 'ament_python' or
            self.build_context.always_run_sphinx_apidoc
        ):

            if not package_src_directory or not os.path.isdir(package_src_directory):
                raise RuntimeError(
                    "Could not locate source directory to invoke sphinx-apidoc in. "
                    "If this is package does not have a standard Python package layout, "
                    "please specify the Python source in 'rosdoc2.yaml'.")
            output_directory = os.path.join(sourcedir, 'generated/python')
            cmd = [
                'sphinx-apidoc',
                '-o', os.path.relpath(output_directory, start=doc_build_folder),
                '-e',  # Document each module in its own page.
                os.path.abspath(package_src_directory),
            ]
            logger.info(
                f"Running sphinx-apidoc: '{' '.join(cmd)}' in '{doc_build_folder}'"
            )
            completed_process = subprocess.run(cmd, cwd=doc_build_folder)
            msg = f"sphinx-apidoc exited with return code '{completed_process.returncode}'"
            if completed_process.returncode == 0:
                logger.info(msg)
            else:
                raise RuntimeError(msg)

        # Invoke Sphinx-build.
        working_directory = doc_build_folder
        sphinx_output_dir = os.path.abspath(os.path.join(doc_build_folder, 'sphinx_output'))
        cmd = [
            'sphinx-build',
            '-c', os.path.relpath(doc_build_folder, start=working_directory),
            os.path.relpath(sourcedir, start=working_directory),
            sphinx_output_dir,
        ]
        logger.info(
            f"Running Sphinx-build: '{' '.join(cmd)}' in '{working_directory}'"
        )
        completed_process = subprocess.run(cmd, cwd=working_directory)
        msg = f"Sphinx-build exited with return code '{completed_process.returncode}'"
        if completed_process.returncode == 0:
            logger.info(msg)
        else:
            raise RuntimeError(msg)

        # Copy the inventory file into the cross-reference directory, but also leave the output.
        inventory_file_name = os.path.join(sphinx_output_dir, 'objects.inv')
        destination = os.path.join(
            self.build_context.tool_options.cross_reference_directory,
            self.build_context.package.name,
            os.path.basename(inventory_file_name))
        logger.info(
            f"Moving inventory file '{inventory_file_name}' into "
            f"cross-reference directory '{destination}'")
        os.makedirs(os.path.dirname(destination), exist_ok=True)
        shutil.copy(
            os.path.abspath(inventory_file_name),
            os.path.abspath(destination)
        )

        # Create a .location.json file as well, so we can know the relative path to the root
        # of the sphinx content from the package's documentation root.
        data = {
            'relative_root': self.output_dir,
        }
        with open(os.path.abspath(destination) + '.location.json', 'w+') as f:
            f.write(json.dumps(data))
        # Put it with the Sphinx generated content as well.
        with open(os.path.abspath(inventory_file_name) + '.location.json', 'w+') as f:
            f.write(json.dumps(data))

        # Return the directory into which Sphinx generated.
        return sphinx_output_dir

    def locate_sphinx_sourcedir_from_standard_locations(self):
        """
        Return the location of a Sphinx project for the package.

        If the sphinx configuration exists in a standard location, return it,
        otherwise return None.  The standard locations are
        '<package.xml directory>/doc/source/conf.py' and
        '<package.xml directory>/doc/conf.py', for projects that selected
        "separate source and build directories" when running Sphinx-quickstart and
        those that did not, respectively.
        """
        package_xml_directory = os.path.dirname(self.build_context.package.filename)
        options = [
            os.path.join(package_xml_directory, 'doc'),
            os.path.join(package_xml_directory, 'doc', 'source'),
        ]
        for option in options:
            if os.path.isfile(os.path.join(option, 'conf.py')) or \
               os.path.isfile(os.path.join(option, 'conf.j2')):
                return option
        return None

    def generate_default_project_into_directory(self, directory):
        """Generate or update the default project configuration files."""
        os.makedirs(directory, exist_ok=True)

        default_conf_j2 = pkg_resources.resource_string(__name__, 'conf.j2').decode('utf-8')
        default_index_j2 = pkg_resources.resource_string(__name__, 'index.j2').decode('utf-8')

        with open(os.path.join(directory, 'conf.j2'), 'w+') as f:
            f.write(default_conf_j2)

        with open(os.path.join(directory, 'index.j2'), 'w+') as f:
            f.write(default_index_j2)

    def generate_wrapping_rosdoc2_sphinx_project_into_directory(
        self,
        directory,
        user_sourcedir,
    ):
        """Generate the rosdoc2 sphinx project configuration files."""
        os.makedirs(directory, exist_ok=True)

        user_conf_py_path = os.path.abspath(os.path.join(user_sourcedir, 'conf.py'))
        user_conf_py = open(user_conf_py_path).read()

        # Execute conf.py and get values of variables
        conf_globals = {}
        conf_locals = {}
        exec(user_conf_py, conf_globals, conf_locals)

        # Convert any paths to absolute paths.
        conf_relpath = os.path.relpath(user_sourcedir)
        for key, value in conf_locals.items():
            if not key.endswith('_path'):
                continue
            if isinstance(value, str):
                conf_locals[key] = os.path.abspath(os.path.join(conf_relpath, value))
            elif isinstance(value, (list, tuple)):
                abs_paths = []
                for item in value:
                    abs_paths.append(os.path.abspath(os.path.join(conf_relpath, item)))
                conf_locals[key] = abs_paths

        # Setup rosdoc2 Sphinx file which will include and extend the one in `sourcedir`.
        wrapped_conf_py = rosdoc2_wrapping_conf_py_preamble
        for key, value in conf_locals.items():
            if isinstance(value, (bool, int, float, list, dict, tuple)):
                wrapped_conf_py += f'{key} = {value}\n'
            elif isinstance(value, str):
                wrapped_conf_py += f'{key} = "{value}"\n'
        wrapped_conf_py += rosdoc2_wrapping_conf_py_template.format_map(self.template_variables)
        with open(os.path.join(directory, 'conf.py'), 'w+') as f:
            f.write(wrapped_conf_py)

    def create_or_update_doc_config_from_templates(self, sourcedir):
        """If conf.j2 or index.j2 found, update conf.py or index.rst"""
        conf_j2_path = os.path.join(sourcedir, 'conf.j2')
        index_j2_path = os.path.join(sourcedir, 'index.j2')

        if os.path.exists(conf_j2_path):
            conf_j2_template = Template(open(conf_j2_path).read())
            conf_py = conf_j2_template.render(self.template_variables)
            conf_py_path = os.path.join(sourcedir, "conf.py")
            with open(os.path.join(conf_py_path), 'w+') as f:
                f.write(conf_py)

        if os.path.exists(index_j2_path):
            index_j2_template = Template(open(index_j2_path).read())
            index_rst = index_j2_template.render(self.template_variables)
            index_rst_path = os.path.join(sourcedir, "index.rst")
            with open(os.path.join(index_rst_path), 'w+') as f:
                f.write(index_rst)

